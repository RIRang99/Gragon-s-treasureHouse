<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // // 语法糖
    // // const obj = new Object()
    // const _arr = new ()
    // console.log(_a)
    // const _arr2 = []
    // // const obj = {} 太糖了 太好用了

    // //! 1.所有的引用类型（数组，函数，对象），都具有对象的特性，可以自由扩展属性
    // const obj = {}  // obj.a = 100
    // const arr = []  // arr.a = 100
    // function fn() { } // fn.a = 100
    // const abc = function () {
    //   console.log('caonima')
    // }
    // //! 2.所有的，都有一个__proto__属性，属性值是一个普通的对象 （__proto__==》 [[prototype]],隐式原型
    // console.log(obj.__proto__)
    // console.log(arr.__proto__)
    // console.log(fn.__proto__)

    // //! 3.所有的函数，都有一个prototype属性，属性值是一个普通的对象
    // console.log(fn.prototype)
    // // ! 4. 所有对象的隐式原型__proto__，都指向它的构造函数的显式原型prototype
    // console.log(obj.__proto__ === Object.prototype)
    // console.log(arr.__proto__ === Array.prototype)
    // console.log(fn.__proto__ === Function.prototype)
    // console.log(abc.prototype)
    // //! 5.当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__中寻找
    // console.log(Function);
    // function fun() {
    //   console.log(111);
    // }
    // fun.prototype.fn = function () {
    //   console.log(this);
    // }

    // // fun()
    // console.dir(Date);
    // console.dir(fn.__proto__.constructor);

    function _Math(num1, num2) {
      this.num1 = num1
      this.num2 = num2
    }

    _Math.prototype.sum = function () {
      return this.num1 + this.num2
    }

    // const obj = {}
    // obj.__proto__ = _Math.prototype
    // _Math.call(obj, 2, 2)
    // console.log(obj.sum());
  </script>
</body>

</html>